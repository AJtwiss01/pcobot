<!DOCTYPE html><html><head><meta charset="utf-8"><style>html { font-size: 100%; overflow-y: scroll; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }

body{
  color:#444;
  font-family:Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman',
              "Hiragino Sans GB", "STXihei", "微软雅黑", serif;
  font-size:12px;
  line-height:1.5em;
  background:#fefefe;
  width: 45em;
  margin: 10px auto;
  padding: 1em;
  outline: 1300px solid #FAFAFA;
}

a{ color: #0645ad; text-decoration:none;}
a:visited{ color: #0b0080; }
a:hover{ color: #06e; }
a:active{ color:#faa700; }
a:focus{ outline: thin dotted; }
a:hover, a:active{ outline: 0; }

span.backtick {
  border:1px solid #EAEAEA;
  border-radius:3px;
  background:#F8F8F8;
  padding:0 3px 0 3px;
}

::-moz-selection{background:rgba(255,255,0,0.3);color:#000}
::selection{background:rgba(255,255,0,0.3);color:#000}

a::-moz-selection{background:rgba(255,255,0,0.3);color:#0645ad}
a::selection{background:rgba(255,255,0,0.3);color:#0645ad}

p{
margin:1em 0;
}

img{
max-width:100%;
}

h1,h2,h3,h4,h5,h6{
font-weight:normal;
color:#111;
line-height:1em;
}
h4,h5,h6{ font-weight: bold; }
h1{ font-size:2.5em; }
h2{ font-size:2em; border-bottom:1px solid silver; padding-bottom: 5px; }
h3{ font-size:1.5em; }
h4{ font-size:1.2em; }
h5{ font-size:1em; }
h6{ font-size:0.9em; }

blockquote{
color:#666666;
margin:0;
padding-left: 3em;
border-left: 0.5em #EEE solid;
}
hr { display: block; height: 2px; border: 0; border-top: 1px solid #aaa;border-bottom: 1px solid #eee; margin: 1em 0; padding: 0; }


pre , code, kbd, samp { 
  color: #000; 
  font-family: monospace; 
  font-size: 0.88em; 
  border-radius:3px;
  background-color: #F8F8F8;
  border: 1px solid #CCC; 
}
pre { white-space: pre; white-space: pre-wrap; word-wrap: break-word; padding: 5px 12px;}
pre code { border: 0px !important; padding: 0;}
code { padding: 0 3px 0 3px; }

b, strong { font-weight: bold; }

dfn { font-style: italic; }

ins { background: #ff9; color: #000; text-decoration: none; }

mark { background: #ff0; color: #000; font-style: italic; font-weight: bold; }

sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }

ul, ol { margin: 1em 0; padding: 0 0 0 2em; }
li p:last-child { margin:0 }
dd { margin: 0 0 0 2em; }

img { border: 0; -ms-interpolation-mode: bicubic; vertical-align: middle; }

table { border-collapse: collapse; border-spacing: 0; }
td { vertical-align: top; }

@media only screen and (min-width: 480px) {
body{font-size:14px;}
}

@media only screen and (min-width: 768px) {
body{font-size:16px;}
}

@media print {
  * { background: transparent !important; color: black !important; filter:none !important; -ms-filter: none !important; }
  body{font-size:12pt; max-width:100%; outline:none;}
  a, a:visited { text-decoration: underline; }
  hr { height: 1px; border:0; border-bottom:1px solid black; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; padding-right: 1em; page-break-inside: avoid; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}
</style><title>README</title></head><body><h1 id="will">Will</h1>
<p>Will is the friendliest, easiest-to-teach bot you've ever used.</p>
<h3 id="he-can">He can:</h3>
<h4 id="hear">Hear</h4>
<pre><code class="python">class CookiesPlugin(WillPlugin):

    @hear(&quot;cookies&quot;)
    def will_likes_cookies(self, message):
        self.say(&quot;I LOOOOVE COOOKIEEESS!!!&quot;)
</code></pre>

<h4 id="reply">Reply</h4>
<pre><code class="python"># All examples below are impled to be on a subclass of WillPlugin

# Basic
@respond_to(&quot;^hi&quot;)
def hi(self, message):
    self.reply(message, &quot;hello, %s!&quot; % message.sender.nick)

# With named matches
@respond_to(&quot;award (?P&lt;num_stars&gt;\d)+ gold stars? to (?P&lt;user_name&gt;.*)&quot;)
def gold_stars(self, message, num_stars=1, user_name=None):
    stars = self.load(&quot;gold_stars&quot;, {})
    stars[user_name] += num_stars
    self.save(&quot;gold_stars&quot;, stars)

    self.say(&quot;Awarded %s stars to %s.&quot; % (num_stars, user_name), message=message)
</code></pre>

<h4 id="do-things-on-a-schedule">Do things on a schedule.</h4>
<pre><code class="python">@periodic(hour='10', minute='0', day_of_week=&quot;mon-fri&quot;)
def standup(self):
    self.say(&quot;@all Standup! %s&quot; % settings.WILL_HANGOUT_URL)
</code></pre>

<h4 id="do-things-randomly">Do things randomly</h4>
<pre><code class="python">@randomly(start_hour='10', end_hour='17', day_of_week=&quot;mon-fri&quot;, num_times_per_day=1)
def walkmaster(self):
    now = datetime.datetime.now()
    in_5_minutes = now + datetime.timedelta(minutes=5)

    self.say(&quot;@all Walk happening in 5 minutes!&quot;)
    self.schedule_say(&quot;@all It's walk time!&quot;, in_5_minutes)
</code></pre>

<h4 id="remember">Remember</h4>
<p>Will can remember almost any python object, even across reboots.</p>
<pre><code class="python">self.save(&quot;my_key&quot;, &quot;my_value&quot;)
self.load(&quot;my_key&quot;, &quot;default value&quot;)
</code></pre>

<h4 id="respond-to-webhooks">Respond to webhooks</h4>
<pre><code class="python"># Simply
@route(&quot;/ping&quot;)
def ping(self):
    return &quot;PONG&quot;

# With templates
@route(&quot;/keep-alive&quot;)
@rendered_template(&quot;keep_alive.html&quot;)
def keep_alive(self):
    return {}

# With full control, multiple templates, still connected to chat.
@route(&quot;/complex_page&quot;)
def complex_page(self):

    self.say(&quot;Hey, somebody's loading the complex page.&quot;)

    header = rendered_template(&quot;header.html&quot;)
    some_other_context = {}
    some_other_context[&quot;header&quot;] = header
    return rendered_template(&quot;complex_page.html&quot;, some_other_context)
</code></pre>

<h4 id="talk-in-html-and-plain-text">Talk in HTML and plain text</h4>
<pre><code class="python">@respond_to(&quot;who do you know about?&quot;)
def list_roster(self, message):
    context = {&quot;internal_roster&quot;: self.internal_roster.values(),}
    self.say(rendered_template(&quot;roster.html&quot;, context), message=message, html=True)
</code></pre>

<h4 id="understand-natural-time">Understand natural time</h4>
<pre><code class="python">@respond_to(&quot;remind me to (?P&lt;reminder_text&gt;.*?) (at|on) (?P&lt;remind_time&gt;.*)&quot;)
def remind_me_at(self, message, reminder_text=None, remind_time=None):
    now = datetime.datetime.now()
    parsed_time = self.parse_natural_time(remind_time)
    natural_datetime = self.to_natural_day_and_time(parsed_time)
    self.say(&quot;%(reminder_text)s %(natural_datetime)s. Got it.&quot; % locals(), message=message)
</code></pre>

<h2 id="full-api">Full API:</h2>
<h3 id="plugin-decorators">Plugin decorators</h3>
<pre><code>&lt;dl&gt;
    &lt;dt&gt;`@hear(regex, include_me=False, case_sensitive=False)`&lt;/dt&gt;
    &lt;dd&gt;
        - `regex`: a regular expression to match.
        - `include_me`: whether will should hear what he says
        - `case_sensitive`: should the regex be case sensitive?
    &lt;/dd&gt;

    &lt;dt&gt;`@respond_to(regex, include_me=False, case_sensitive=False)`&lt;/dt&gt;
    &lt;dd&gt;
        - `regex`: a regular expression to match.
        - `include_me`: whether will should hear what he says
        - `case_sensitive`: should the regex be case sensitive?
    &lt;/dd&gt;

    &lt;dt&gt;@periodic(*periodic_args)&lt;/dt&gt;
    &lt;dd&gt;
        Args are parsed by [apscheduler](http://apscheduler.readthedocs.org/en/latest/cronschedule.html#available-fields).

        - `year`: 4-digit year number
        - `month`: month number (1-12)
        - `day`: day of the month (1-31)
        - `week`: ISO week number (1-53)
        - `day_of_week`: number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun)
        - `hour`: hour (0-23)
        - `minute`: minute (0-59)
        - `second`: second (0-59)

        The following expressions are valid:

        - `*` (any): Fire on every value
        - `*/a` (any): Fire every a values, starting from the minimum
        - `a-b` (any): Fire on any value within the a-b range (a must be smaller than b)
        - `a-b/c` (any): Fire every c values within the a-b range
        - `xth y` (day): Fire on the x -th occurrence of weekday y within the month
        - `last x` (day): Fire on the last occurrence of weekday x within the month
        - `last` (day): Fire on the last day within the month
        - `x,y,z` (any): Fire on any matching expression; can combine any number of any of the above expressions
    &lt;/dd&gt;

    &lt;dt&gt;@randomly(start_hour=0, end_hour=23, day_of_week=&quot;*&quot;, num_times_per_day=1)&lt;/dt&gt;
    &lt;dd&gt;
        - `start_hour`: the earliest a random task could fall.
        - `end_hour`: the latest hour a random task could fall (inclusive, so end_hour:59 is a possible time.)
        - `day_of_week`: valid days of the week, same expressions available as `@periodic`
        - `num_times_per_day`: number of times this task should happen per day.
    &lt;/dd&gt;

    &lt;dt&gt;@route(routing_rule)&lt;/dt&gt;
    &lt;dd&gt;
        - `routing_rule`:  A ()
    &lt;/dd&gt;
&lt;/dl&gt;

@rendered_template(&quot;template_name.html&quot;)
</code></pre>

<h3 id="high-level-chat-methods">High-level chat methods</h3>
<pre><code>self.say(content, message=None, room=None, html=False, color=&quot;green&quot;, notify=False)
self.reply(message, content, html=False, color=&quot;green&quot;, notify=False)
    # note html is stripped for 1-1 messages
self.set_topic(self, topic, message=None, room=None)
    # note you can't set the topic of a 1-1
self.schedule_say(content, when, message=None, room=None, html=False, color=&quot;green&quot;, notify=False)
self.parse_natural_time(remind_time)
self.to_natural_day_and_time(parsed_time)
</code></pre>

<h3 id="high-level-helpers">High-level helpers:</h3>
<pre><code>self.rendered_template(template_name, context={})
</code></pre>

<h3 id="low-level-chat-methods">Low-level chat methods:</h3>
<p>Advanced
- change topic
- multiple rooms
- 1-1 chat</p>
<p>Will supports:
- Replies
- Scheduled tasks
- One-time tasks
- Random tasks
- Every-message listening
- A web server, via Bottle
- Full HTML templating, via Jinja</p>
<h2 id="setup-via-pip">Setup via pip</h2>
<ol>
<li>Install via <code>pip install will</code>, or fork and clone this repo.</li>
<li>Set environment variables:</li>
</ol>
<p>```
    # Required
    export WILL_USERNAME='12345_123456@chat.hipchat.com'
    export WILL_PASSWORD='asj2498q89dsf89a8df'
    export WILL_TOKEN='kjadfj89a34878adf78789a4fae3'
    export WILL_V2_TOKEN='asdfjl234jklajfa3azfasj3afa3jlkjiau'
    export WILL_ROOMS='Testing, Will Kahuna;GreenKahuna'  # Semicolon-separated, so you can have commas in names.
    export WILL_NAME='William T. Kahuna'
    export WILL_HANDLE='will'
    export WILL_REDIS_URL="redis://localhost:6379/7"</p>
<pre><code># Optional / Production

# Default room: (otherwise defaults to the first of WILL_ROOMS)
export WILL_DEFAULT_ROOM='12345_room1@conf.hipchat.com'

# For google hangouts:
export WILL_HANGOUT_URL='https://plus.google.com/hangouts/_/event/ceggfjm3q3jn8ktan7k861hal9o'

# If will isn't accessible at localhost (heroku, etc):
export WILL_URL="http://my-will.herokuapp.com/"

# Defaults to 80
export WILL_HTTPSERVER_PORT="80"

```
</code></pre>
<ol>
<li>Run will. <code>will</code></li>
</ol>
<h2 id="sample-code">Sample Code:</h2>
<p>Will was designed to make building a bot easy, fun, and simple.  Here are some examples.</p>
<p>To Doc:
- only need message if
    : reply
    : more than one room.</p>
<pre><code class="python">
class GoldStarPlugin(WillPlugin):

    @respond_to(&quot;award (?P&lt;num_stars&gt;\d)+ gold stars? to (?P&lt;user_name&gt;.*)&quot;)
    def gold_stars(self, message, num_stars=1, user_name=None):
        stars = self.load(&quot;gold_stars&quot;, {})
        if user_name in stars:
            stars[user_name] += num_stars
        else:
            stars[user_name] = num_stars

        self.save(&quot;gold_stars&quot;, stars)

        self.saymessage, (&quot;Awarded %s stars to %s.&quot; % (num_stars, user_name))



class NewTopicPlugin(WillPlugin):

    @respond_to(&quot;new topic (?P&lt;topic&gt;.*)&quot;)
    def new_topic(self, message, topic=&quot;Something or other. You weren't terribly specific.&quot;):
        self.set_topic(message, topic)



class CookiesPlugin(WillPlugin):

    @hear(&quot;cookies&quot;, include_me=False)
    def will_likes_cookies(self, message):
        self.say(rendered_template(&quot;cookies.html&quot;, {}), message=message, html=True, )


class WalkmasterPlugin(WillPlugin):

    @randomly(start_hour=8, end_hour=6, weekdays_only=True)
    def go_for_a_walk(self):
        self.say(&quot;@all time for a walk!&quot;, room=&quot;GreenKahuna&quot;)
        self.set_topic(&quot;Walk Time!&quot;)


class KeepAlivePlugin(WillPlugin):

    @periodic(run_every=crontab(minute=1))
    def go_for_a_walk(self):
        requests.get(&quot;%s/keep-alive&quot; % settings.WILL_URL)

    @route(&quot;/keep-alive&quot;)
    def keep_alive(self):
        return rendered_template(&quot;keep_alive.html&quot;, {})

</code></pre>

<h3 id="deploying-on-heroku">Deploying on heroku</h3>
<ul>
<li>forking</li>
<li>pip installing</li>
</ul>
<h3 id="shoulders-of-giants">Shoulders of Giants</h3>
<p>Will leverages some fantastic libraries.  He wouldn't exist without them.</p>
<ul>
<li>Bottle for http handling</li>
<li>Jinja for templating</li>
<li>Sleepxmpp for listening to xmpp</li>
<li>natural and parsedatetime for natural date parsing</li>
<li>apscheduler for scheduled task parsing</li>
<li>Requests to make http sane.</li>
</ul></body></html>